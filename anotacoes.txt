em um pacote para matchers...

matchers proprios devem ser feitos em classes separadas, importando TypeSafeMatcher do Hamcrest , passando como <generic> o tipo de dado que será recebido pela classe
public class DiaSemanaMatcher extends TypeSafeMatcher<Date> {...}

depois, junte os métodos numa classe onde se chamará os matcher criados a partir do nome que for definido. o método deve ser static
public static DiaSemanaMatcher caiem(Integer diaSemana) {
	return new DiaSemanaMatcher(diaSemana);
}

em casos de erro, é possível formatar a descrição
no método describeTo

SUÍTE DE TESTES

serve para executar todos os testes em apenas uma bateria 

ficam em pacotes separados 
a classe deverá possuir a anotação a seguir e depois, a declaração das classes que pertencerão à suite de testes 

@RunWith(Suite.class)
@SuiteClasses({
	Classe1Teste.class,
	Classe2Teste.class,
	Classe3Teste.class
})

a classe em si não é importante
aqui pode ser necessário o uso do @BeforeClass e @AfterClass para definir alguma confiuração inicial, principalmente quando se tratar de testes que envolvam banco 

desvantagem: 
classes novas deverão ser adicionadas a suite conforme o andamento do projeto
as execuções ficarão duplicadas, exemplo de execução: teste1, teste2, teste3, SUITE[teste1, teste2, teste3], ...

CRIAÇÃO DE DADOS P/ TESTE

servem para facilitar a declaração de objetos necessários ao teste

pacote para builders 
ObjetoBuilder

na classe, deve-se definir:
- um contrutor privado
- atributo p/ referneciar a classe
- método public static que irá gerar o objeto segundo as caracteristicas desejadas, será static p/ poder ser chamado sem instância. retorna um objeto da propria classe
exemplo: objetoDaClasse.atributoQueReferenciaClasse = new ClasseReferenciada("construa"); retorne;
- método que irá retornar o objeto gerado (build)

a classe pode conter:
- chain methods, que irão complementar alguma atributo do objeto, para se encaixar em um cenário específico. retornam this.
*quando o cenário em que é necessário utilizar chain methods várias vezes, recomenda-se a criação de outro método static, para defirnir o objeto com caracteristicas distintas

BUILDER MASTER 

automatiza a criação dos builders 
adicione a lib e dê build path

faça um método main chamando o builder master passando como parâmetro a classe que se deseja gerar o builder
execute como java app e o código será gerado no console
crie a classe, cole o código e se quiser, defina os valores padrões às variáveis

ANÁLISE DE COBERTURA

métricas dos testes unitários: 
- percentual de aceitação dos testes 
- percentual de cobertura de código 

percentual de aceitação dos testes = testes executados com sucesso / testes executados 
barra verde = 100% de aceitação 

cobertura com EclEmma 
verde = linha executada completamente 
amarela = linha executada parcialmente (a linha pode conter lógica que cause desvio/branches)
vermelho = a linha não foi executada

100% de cobertura não garante um teste 100% seguro, pode ser que mais cenários para ser testados estejam valtando 
a métrica de cobertura é de no mínimo 75% 
maior utilidade: verificar as linhas vermelhas

deve-se preocupar em atingir 100% de aceitação

DEPENDÊNCIAS EXTERNAS 

testes unitários não acessam dependências externas (banco, arquivos, rede, etc)
caso possuam, isso impactará nos princípios fundamentais dos testes unitários:

FAST -> acesso a dependências externas toma mais tempo e vai contra este princípio 
INDEPENDENT -> os testes não ficarão mais isolados 
REPEATABLE -> é difícil garantir que dependências externas fiquem sempre no mesmo estado, contribuindo assim para a quebra dos testes
SELF-VERIFYING -> perderá auto-rastreabilidade 
TIMELY -> conexões com o ambiente externo podem não ser estáveis 100% do tempo, ou os serviços necessários podem estar fora do ar. o teste pode ficar indisponível ou quebrar

suites de testes que utilizam dependências externas possuem notória diferença no tempo de execução e falhas
quando é necessário acessar serviços externos, utilizamos mocks

a partir de agora trabalharemos com persistência de dados e DAO para a locação
testes que trabalham com persistência de dados são testes de integração

OBJETOS FALSOS

com o dao, os testes quebrarão
para voltar a funcionar, deveriam instanciar o DAO 

problema: 
- o DAO não está completo
- os testes deixarão de ser isolados 

solução 1: fake object
criar uma classe DAO fake para injetar nos testes para que voltem a funcionar
eficaz para isolar o teste do ambiente externo 
desvantagem -> todo DAO irá precisar de uma classe fake

MOCK

em vez de gerar objetos fake, gera objetos mock 
com esses objetos, será possível definir comportamentos dinâmicos 

"um mock é uma instância de um objeto que para todos os efeitos, responde como se estivesse implementando a classe que ele utilizou como origem"
é genérico, então ele não sabe como se comportar
possui comportamento padrâo de acordo com a assinatura do método 

[tipo/retorno ou comportamento padrão]
void: sem ação 
string: string vazia
numeros: zero
objeto: null